# -*- coding: utf-8 -*-
"""tensorflow1_15___regressão_linear.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WaNKFhMP5ko4YMzntHRauP4EVqLb4pTs
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import tensorflow as tf

from sklearn.preprocessing import StandardScaler
from sklearn.metrics import mean_absolute_error, mean_squared_error
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import MinMaxScaler

import os
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3' 

# Próxima linha necessária apenas no jupyternotebook ou google colab
# %matplotlib inline

base = pd.read_csv('house-prices.csv')
base_size = base.shape
base.head()

# Aula 009 - Regressão linear com Sklearn - Tensorflow: Regressão Linear

# -- exemplo 01: custo do plano de saúde pela idade --

idades = np.array([[18], [23], [28], [33], [38], [43], [48], [53], [58], [63]])
custos = np.array([[871], [1132], [1042], [1356], [1488], [1638], [1569], [1754], [1866], [1900]])

regressor = LinearRegression()
regressor.fit(idades, custos)

# Fórmula da regressao linear simples | y = b0 + b1 * x1

b0 = regressor.intercept_
b1 = regressor.coef_

print(f'b0 - {b0}')
print(f'b1 - {b1}')

x1 = 40 # idade
previsao1_1 = b0 + b1 * x1
previsao1_2 = regressor.predict( np.array( [ [x1] ] ) )

previsoes = regressor.predict(idades)
resultados = abs(custos - previsoes)

mae = mean_absolute_error(custos, previsoes)
mse = mean_squared_error(custos, previsoes)

print()
print(f'previsao1.1 = {previsao1_1}', end='\n'*2)
print(f'previsao1.2 = {previsao1_2}', end='\n'*2)
print(f'previsões \n{previsoes}', end='\n'*2)
print(f'resultados \n{resultados}', end='\n'*2)

# Usado para comparação de resultados
print(f'MEAN ABSOLUTE ERRORs - {mae}', end='\n'*2)
# Usado para o treinamento
print(f'MEAN SQUARE ERRORs - {mse}', end='\n'*2)

plt.plot(idades, custos, 'o')
plt.plot(idades, previsoes, color='red')
plt.title('Exemplo de regressão linear simples: plano de saúde')
plt.xlabel('Idade')
plt.ylabel('Custo')
print()

# Aula 010 - Regressão linear com Tensorflow - Tensorflow: Regressão Linear

# -- exemplo 01: custo do plano de saúde pela idade --

idades = np.array([[18], [23], [28], [33], [38], [43], [48], [53], [58], [63]])
custos = np.array([[871], [1132], [1042], [1356], [1488], [1638], [1569], [1754], [1866], [1900]])

# Escalonamento dos dados
scaler_idades = StandardScaler()
idades = scaler_idades.fit_transform(idades)
scaler_custos = StandardScaler()
custos = scaler_custos.fit_transform(custos)

# Fórmula da regressao linear simples | y = b0 + b1 * x1

np.random.seed(0)
x, y = np.around(np.random.rand(2), 2) # apenas duas casas decimais

b0 = tf.Variable(x, name='b0')
b1 = tf.Variable(y, name='b1')
init = tf.global_variables_initializer()

# cálculo do erro
erro = tf.losses.mean_squared_error(custos, (b0 + b1 * idades))
# otimizador com descida do gradiente
otimizador = tf.train.GradientDescentOptimizer(learning_rate = 0.001)
# treinamento para minimizar o erro
treinamento = otimizador.minimize(erro)

with tf.Session() as sess:
  sess.run(init)
  #print(f'sess.run(b0) - {sess.run(b0)}')
  #print(f'sess.run(b1) - {sess.run(b1)}')
  epocas = 1000 # quantidade de treinamento
  for i in range(epocas):
    sess.run(treinamento)
  b0_final, b1_final = sess.run([b0, b1])

print(f'b0_final - {b0_final}')
print(f'b1_final - {b1_final}', end='\n'*2)

previsoes = b0_final + b1_final * idades
print(f'previsoes \n{previsoes}')

plt.plot(idades, custos, 'o')
plt.plot(idades, previsoes, color='r')
plt.title('Exemplo de regressão linear simples: plano de saúde')
plt.xlabel('Idade')
plt.ylabel('Custo')

print()
idade = scaler_idades.transform([[40]]) # escalonando a idade
previsao = scaler_custos.inverse_transform( b0_final + b1_final * idade )
print(f'previsao - {previsao}')

custos1 = scaler_custos.inverse_transform(custos)
previsoes1 = scaler_custos.inverse_transform(previsoes)

mae = mean_absolute_error(custos1, previsoes1)
mse = mean_squared_error(custos1, previsoes1)

print(f'MEAN ABSOLUTE ERROR - {mae}')
print(f'MEAN SQUARE ERROR - {mse}', end='\n'*2)

# Aula 011 - Previsão do preço de casas - Tensorflow: Regressão Linear

# recuperando a coluna com os tamanhos das casas
tamanho_casa = base.iloc[:, 5:6].values
# recuperando a coluna com os preços das casas
preco_casa = base.iloc[:, 2:3].values

# escalonando valores
scaler_tamanho = StandardScaler()
tamanho_casa = scaler_tamanho.fit_transform(tamanho_casa)
scaler_preco = StandardScaler()
preco_casa = scaler_preco.fit_transform(preco_casa)

# Fórmula da regressao linear simples | y = b0 + b1 * x1

np.random.seed(1)
x, y = np.around(np.random.rand(2), 2)

b0 = tf.Variable(x, name='b0')
b1 = tf.Variable(y, name='b1')
init = tf.global_variables_initializer()

# batch_size serve para não sobrecarregar os métodos passando toda base de dados, é como um buffer 
batch_size = 32
preco_casa_ph = tf.placeholder(tf.float64, [batch_size, 1])
tamanho_casa_ph = tf.placeholder(tf.float64, [batch_size, 1])

preco_casa_modelo = b0 + b1 * tamanho_casa_ph

erro = tf.losses.mean_squared_error(preco_casa_ph, preco_casa_modelo)
otimizador = tf.train.GradientDescentOptimizer(learning_rate = 0.001)
treinamento = otimizador.minimize(erro)

with tf.Session() as sess:
  sess.run(init)
  epocas = 10000
  for i in range(epocas):
    indices = np.random.randint(base_size[0], size = batch_size)
    feed = {tamanho_casa_ph: tamanho_casa[indices], preco_casa_ph: preco_casa[indices]}
    sess.run(treinamento, feed_dict = feed)
  b0_final, b1_final = sess.run([b0, b1])

print(f'b0_final - {b0_final}')
print(f'b1_final - {b1_final}', end='\n'*2)

previsoes = b0_final + b1_final * tamanho_casa
print(f'previsoes \n{previsoes}', end='\n'*2)

plt.plot(tamanho_casa, preco_casa, 'o')
plt.plot(tamanho_casa, previsoes, color='r')
plt.title('Exemplo de regressão linear simples: preço de casas pelo tamanho')
plt.xlabel('Tamanho')
plt.ylabel('Preço')

preco_casas1 = scaler_preco.inverse_transform(preco_casa)
previsoes1 = scaler_preco.inverse_transform(previsoes)

mae = mean_absolute_error(preco_casas1, previsoes1)
print(f'MEAN ABSOLUTE ERROR - {mae}', end='\n'*2)

# Aula 012 - Regressão linear simples com Estimators - Tensorflow: Regressão Linear

# recuperando a coluna com os tamanhos das casas
tamanho_casa = base.iloc[:, 5:6].values
# recuperando a coluna com os preços das casas
preco_casa = base.iloc[:, 2:3].values

# escalonando dados
scaler_tamanho = StandardScaler()
tamanho_casa = scaler_tamanho.fit_transform(tamanho_casa)
scaler_preco = StandardScaler()
preco_casa = scaler_preco.fit_transform(preco_casa)

colunas = [tf.feature_column.numeric_column('tamanho_casa', shape=[1])]

regressor = tf.estimator.LinearRegressor(feature_columns = colunas)

tamanho_casa_treinamento, tamanho_casa_teste, preco_casa_treinamento, preco_casa_teste = train_test_split(tamanho_casa, preco_casa, test_size = 0.3)
funcao_treinamento = tf.estimator.inputs.numpy_input_fn({'tamanho_casa': tamanho_casa_treinamento}, preco_casa_treinamento, batch_size = 32, num_epochs = None, shuffle = True)
funcao_teste = tf.estimator.inputs.numpy_input_fn({'tamanho_casa': tamanho_casa_teste}, preco_casa_teste, batch_size = 32, num_epochs = 1000, shuffle = False)

regressor.train(input_fn=funcao_treinamento, steps = 10000)

metricas_treinamento = regressor.evaluate(input_fn = funcao_treinamento, steps = 10000)
print(metricas_treinamento)
metricas_teste = regressor.evaluate(input_fn = funcao_teste, steps = 10000)
print(metricas_teste)

novas_casas = np.array([[800], [900], [1000]])
novas_casas = scaler_tamanho.transform(novas_casas)

funcao_previsao = tf.estimator.inputs.numpy_input_fn({'tamanho_casa':novas_casas}, shuffle = False)
previsoes = regressor.predict(input_fn = funcao_previsao)

for p in previsoes:
  print(scaler_preco.inverse_transform(p['predictions']))

# Aula 013 - Regressão linear multipla com Estimators - Tensorflow: Regressão Linear

colunas_usadas = ['price', 'bedrooms', 'bathrooms', 'sqft_living',
                  'sqft_lot', 'floors', 'waterfront', 'view', 'condition', 'grade',
                  'sqft_above', 'sqft_basement', 'yr_built', 'yr_renovated', 'zipcode',
                  'lat', 'long']

base = pd.read_csv('house-prices.csv', usecols = colunas_usadas)

# normalizando os dados
scaler_attrs = MinMaxScaler()

base[['bedrooms', 'bathrooms', 'sqft_living',
      'sqft_lot', 'floors', 'waterfront', 'view', 'condition', 'grade',
      'sqft_above', 'sqft_basement', 'yr_built', 'yr_renovated', 'zipcode',
      'lat', 'long']] = scaler_attrs.fit_transform(base[['bedrooms', 'bathrooms', 'sqft_living',
                                                    'sqft_lot', 'floors', 'waterfront', 'view', 'condition', 'grade',
                                                    'sqft_above', 'sqft_basement', 'yr_built', 'yr_renovated', 'zipcode',
                                                    'lat', 'long']])

scaler_preco = MinMaxScaler()
base[['price']] = scaler_preco.fit_transform(base[['price']])

base.head()

casa_attrs = base.drop('price', axis = 1) # todos atributos da base menos o preço (axis = 1 apaga toda coluna)
casa_preco = base.price

previsores_colunas = colunas_usadas[1:17]

colunas = [tf.feature_column.numeric_column(key = c) for c in previsores_colunas]

casa_treinamento, casa_teste, preco_treinamento, preco_teste = train_test_split(casa_attrs, casa_preco, test_size = 0.3)

funcao_treinamento = tf.estimator.inputs.pandas_input_fn(x = casa_treinamento, y = preco_treinamento,
                                                         batch_size = 32, num_epochs = None, shuffle = True)

funcao_teste = tf.estimator.inputs.pandas_input_fn(x = casa_teste, y = preco_teste, batch_size = 32,
                                                   num_epochs = 10000, shuffle = False)

regressor = tf.estimator.LinearRegressor(feature_columns = colunas)

regressor.train(input_fn = funcao_treinamento, steps = 10000)

metricas_treinamento = regressor.evaluate(input_fn = funcao_treinamento, steps = 10000)
metricas_testes = regressor.evaluate(input_fn = funcao_teste, steps = 10000)
print()
print(metricas_treinamento)
print(metricas_teste)

funcao_previsao = tf.estimator.inputs.pandas_input_fn(x = casa_teste, shuffle = False)
previsoes = regressor.predict(input_fn = funcao_previsao)

valores_previsoes = []
for p in previsoes:
  valores_previsoes.append(p['predictions'])

# convertento de lista para uma matriz numpy
valores_previsoes = np.asarray(valores_previsoes).reshape(-1, 1)
preco_teste_2 = preco_teste.values.reshape(-1, 1)

# voltando aos valores originais
valores_previsoes = scaler_preco.inverse_transform(valores_previsoes)
preco_teste_2 = scaler_preco.inverse_transform(preco_teste_2)

# comparando as previsões com os testes

mae = mean_absolute_error(preco_teste_2, valores_previsoes)
print(f'\nMEAN ABSOLUTE ERROR - {mae}')